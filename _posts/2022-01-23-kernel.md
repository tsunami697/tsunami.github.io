---
layout:     post   				    # 使用的布局（不需要改）
title:      Kernel-tmp 				# 标题 
subtitle:   记录内核学习 #副标题
date:       2022-07-24 				# 时间
author:     Qi 						# 作者
header-img: img/post-bg-2015.jpg 	# 这篇文章标题背景图片
catalog: true 						# 是否归档
<<<<<<< HEAD
tags:								#标签
    - tmp
=======
tags:								# 标签
    - kernel
>>>>>>> a9c4ce6515540f1b3d42deb2b853c7986fac061c
---

# linux内核

## 1 操作系统的结构

## 2 操作系统的工作方式
1. 把操作系统从用户态切换到内核态（用户应用程序到内核的流程）
2. 实现操作系统的系统调用（操作系统服务层）
3. 应用操作系统提供底层服务，进行功能实现  
	a. 操作系统的驱动结构
4. 退出后从内核态切换到用户态

## 3 操作系统中内核各级模块相互关联
### 3.1 Linux内核的整体模块：
进程调度模块、内存管理模块、文件系统模块、进程间通信模块、
驱动管理模块
### 3.2 每个模块间的关系
1. 内存管理和驱动管理模块：虚拟内存的缓存和回存机制
2. VFS虚拟文件系统：把硬件当成文件进行使用

## 4 操作系统结构的独立性
1. 管理层、实现层  
这样易于升级和维护	1991 Linux-0.11搭建了骨架  
2. 高版本的内核、低版本的内核之间的区别  
多的是内核驱动的种类		内核驱动的管理模式并没有巨大改变（一段时间 3个各阶段的跳段 零散型 分层型 设备数）  
进程的调度算法发生了改变	进程的管理方式并没有巨大的改变  
3. 不变的才是永恒的

## 学习中断的目的：  
1. 硬件的中断相应--->内核驱动(裸机驱动)的中断  
2. 系统调用的函数响应(sys_call) --->系统调用   
3. 自定义中断--->软件的软中断模式  
4. 信号中断(kill -signalnum)--->对了解信号的使用、创建等  
5. 系统的异常和错误-->系统的异常获取,了解系统异常的作用
## 5. linux的中断机制
### 5.1 分类：硬件中断 软件中断
1. 硬中断：  
由电脑主机的8259A类似的硬件中断控制芯片发出的中断  
ARM中断控制器发出的中断  
2. 软中断：  
异常 第一类：CPU自行保留的中断  
系统调用异常
### 5.2 内核中断代码结构
文件：asm.s : trap.c  
system_call.s : fork.c signal.c  exit.c  sys.c
### 5.3 中断的工作流程
### 5.3.1 回忆
1. 做CPU工作模式的转换  
2. 进行寄存器的拷贝与压栈  
3. 设置中断异常向量表  
4. 保存正常运行的函数返回值  
5. 跳转到对应的中断服务函数上运行  
6. 进行模式的复原以及寄存器的复原  
7. 跳转到正常工作的函数地址继续运行  
### 5.3.2 Linux中断的工作流程
1. 将所有的寄存器入栈  
(8086) SS EFLAGS ESP CS EIP (错误码) ARM中的（r0-r15）  
(linux-0.11 80386)
2. 将异常码入栈(中断号)
3. 将当前的函数返回值入栈（为了在中断执行后能够找到在哪中断的，能够复原）  
以上是保存工作
4. 调用对应的中断服务函数  
以上是执行中断操作
5. 出栈函数返回值
6. 返回所有入栈的寄存器值
### 5.3.3 中断代码的实现过程
