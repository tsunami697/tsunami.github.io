---
layout:     post   				    # 使用的布局（不需要改）
title:      Kernel-操作系统结构与功能流程	# 标题 
subtitle:   内核学习 #副标题
date:       2022-07-24 				# 时间
author:     Qi 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - kernel
---
# 操作系统结构与功能流程

## 目录
|  序号  |  内容  |  课时  |
| :---: | :---: | :---: |
|linux内核体系结构|内核模式与体系结构|2|
||内核中断概述|2|
||内核进程管理概括|5|
|linux内核源码结构|linux内核源码宏观结构|2|
||linux内核源码各级源码分类|2|
||linux内核源码解析第一刀|2|
|linux内核引导程序|linux内核启动程序分析|2|
||linux内核初始化程序分析|2|
||linux第一个进程分析|2|
|linux内核进程管理|||
|linux内核内存管理|||
|linux内核驱动管理|||

## 1. 操作系统的结构
|linux系统结构|
|:---:|
|用户应用程序|
|操作系统的服务层 如系统调用服务sys_call|
|操作系统内核 如文件系统、内存管理、进程管理、驱动管理|
|硬件系统 驱动|
|硬件|

## 2. 操作系统的工作方式
1. 把操作系统从用户态切换到内核态（用户应用程序 到 内核的流程）
2. 实现操作系统的系统调用（操作系统服务层实现）
3. 使用操作系统提供底层服务，进行调用的功能实现
    3.1 操作系统的驱动结构
4. 退出后从内核态切换到用户态

## 3. 操作系统中内核各级模块的相互关联

### 3.1 Linux内核的整体模块
* 进程调度模块（创建、更新、轮转、销毁）
* 内存管理模块
* 文件系统模块
* 进程间通信模块（和进程调度不同，需要另外的函数实现）
* 驱动管理模块

### 3.2 模块间的关系
比如：
* 内存管理和驱动管理模块：虚拟内存的缓存和回存机制（暂时不用的代码放在硬盘）
* VFS虚拟文件系统（把硬件当成文件）：Linux把硬件当成文件进行使用，把硬件虚拟成文件（read(fd,...)
* 进程调度和进程通信

---
**用户态**
```
flowchart LR
    用户程序 --> 标准库或SDK
```
---
**内核态**
*  很多模块相互之间都有关系。
```
flowchart LR
    操作系统的服务层-系统调用接口<-->
    文件系统-VFS<--> 进程管理模块/进程通信模快
    操作系统的服务层-系统调用接口<-->进程管理模块/进程通信模块
    
    文件系统-VFS <--> 内存管理模块
    文件系统-VFS <--> 驱动管理模块-字符设备/块设备/网络设备 <--> 硬件系统(各种硬件驱动的实现)
    
    操作系统的服务层-系统调用接口
    文件系统-VFS
    进程管理模块/进程通信模快
    内存管理模块
    驱动管理模块-字符设备/块设备/网络设备
    硬件系统(各种硬件驱动的实现)
```
---
**硬件层**

---

## 4 操作系统结构的独立性
* Linux内核设计思想：管理层、实现层
这样易于升级和维护	1991 Linux-0.11搭建了骨架
* 高版本的内核、低版本的内核之间的区别
    * 多的是内核驱动的种类, 内核驱动的管理模式并没有巨大改变（一段时间 3个各阶段的跳段：零散型 分层型 设备树）
* 进程的调度算法发生了改变, 进程的管理方式并没有巨大的改变
* **不变的才是永恒的**

# 内核中断概括
## 学习中断的目的
* 硬件的中断响应--->内核驱动(裸机驱动)的中断，要熟悉Linux内核的中断体系？
* 系统调用的函数响应(sys_call) --->系统调用通过中断，系统中断怎么实现和流程是怎样的？
* 自定义中断--->软件的软中断模式是什么？
* 信号中断(kill -signalnum)--->了解信号的使用、创建等。信号和进程的关系是怎样的？
* 系统的异常和错误-->系统的异常获取,了解系统异常的作用。异常和错误不同，异常是一种很好的机制。
**以上都是通过中断完成**

## 5 linux的中断机制
### 5.1 分类：硬件中断 软件中断
1. 硬中断
* 由电脑主机的8259A类似的硬件中断控制芯片发出的中断
* ARM中断控制器发出的中断

2. 软中断-也叫异常
* 第一类：CPU自行保留的中断
* 第二类：系统调用异常

### 5.2 内核中断代码结构
文件在kernel目录下
asm.s:         trap.c
system_call.s: fork.c signal.c  exit.c  sys.c

### 5.3 中断的工作流程
### 5.3.1 回忆
1. 做CPU工作模式的转换：更改寄存器
2. 进行寄存器的拷贝与压栈
3. 设置中断异常向量表
4. 保存正常运行的函数返回值
5. 跳转到对应的中断服务函数上运行
6. 进行模式的复原以及寄存器的复原
7. 跳转到正常工作的函数地址继续运行

### 5.3.2 Linux中断的工作流程
* 过程
1. 将所有的寄存器入栈：对当前寄存器值保存
    * 8086中的 SS EFLAGS ESP CS EIP (错误码) 
    * ARM中的 r0-r15
    * linux-0.11 跑在80386
2. 将异常码入栈(中断号)
3. 将当前的函数返回值入栈（为了在中断执行后能够找到在哪中断的，能够复原）
**以上是保存工作**
4. 调用对应的中断服务函数
**以上是执行中断操作**
5. 出栈函数返回值
6. 返回所有入栈的寄存器值

* 流程图
```
flowchart LR

将所有的寄存器入栈-->将异常码入栈-->将对应的返回值入栈-->调用对应的中断服务函数-->出栈函数返回值-->返回所有入栈的寄存器值

```
* 中断处理过程对应的代码

||中断前的处理过程/中断的恢复过程|中断的执行过程|
|:--:|:--:|:--:|
|硬件中断的处理过程|asm.s|trap.c|
|软件及系统调用的处理过程|system_call.s| fork.c signal.c  exit.c  sys.c|

### 5.3.3 中断代码的实现过程
1. 分析硬中断的处理过程：asm.s 和 trap.c
https://github.com/tsunami697/linux-0.11/

* asm.s分析：入栈 sp -, 出栈 sp +

|栈的内存分布||
|:--:|:--:|
|SS地址|高地址|
|EFLAGS||
|ESP||
|CS||
|EIP||
|有出错码就进行压栈，无出错码就不做||
|EIP（函数的返回值寄存器值）||
|中断处理函数的调用C函数入口地址||
|EBX||
|ECX||
|EDX||
|EDI||
|ESI||
|EBP||
|DS||
|ES||
|ERROR CODE||
|ESP（中断的返回地址）|低地址|

* trap.c分析
trap_init
    set_trap_gate 设置的权限高，只能由用户程序调用
    set_system_gate 设置的权限低，能由用户和系统所有的进程调用
